
;connected-subpatterns-with-var
(= (is-blk-more-abstract $head $pivot $var) True)
;argumets: $paratition (the target patition which is a list of blocks)
;$var the variable we are concerned with

;Returns:
;The blocks inside the partiton that contain the target variable $var
;
;================================
;  (=(connected-subpatterns-with-var $partition $var)
;     (collapse 
;         (rmvPar (process-pattern (superpose $partition ) $var))))

(=(connected-subpatterns-with-var $partition $var)
    (rmvPar (process-patterns-recursive $partition $var))
)

; Recursively process all patterns in the partition
(=(process-patterns-recursive $partition $var)
    (if (== $partition ())
        ()
        (if (== (get-metatype $partition) Expression)
            (let $head (car-atom $partition)
                (let $tail (cdr-atom $partition)
                    (let $head_result (process-pattern $head $var)
                        (let $tail_result (process-patterns-recursive $tail $var)
                            (if (== $head_result ())
                                $tail_result
                                (if (== $tail_result ())
                                    (cons-atom $head_result ())
                                    (cons-atom $head_result $tail_result)
                                )
                            )
                        )
                    )
                )
            )
            (let $result (process-pattern $partition $var)
                (if (== $result ())
                    ()
                    (cons-atom $result ())
                )
            )
        )
    )
)


; (= (checkInterSuper $var $el) (if (checkPat $el) 
;     (let $tail (cdr-atom $el) 
;         (checkInterSuper $var (superpose $tail)) ) 
;             (if (== $var $el) True (empty))) )  

; (=(process-pattern $pattern $var)
;     (let* (
;         ($is_pat (checkPat $pattern)))
    
;         (if $is_pat
;             ; If it's a pattern, do the normal check
;             (let* (
       
;                 ($exp (if (== (size-atom $pattern) 1) (car-atom $pattern) $pattern))
;                 ($vars (cdr-atom $exp))
               
;                 ($is_connected (checkInterSuper $var (superpose $vars)))
;             )
;                 (if $is_connected
;                     $pattern
;                     (empty)
;                 )
;             )
;             (let $ch (collapse (process-pattern (superpose $pattern) $var)) (if (not (== $ch ())) $pattern (empty) )) ;activate this for returning the whole block, comment out if not
;         )
;     ))


(=(process-pattern $pattern $var)
    (let $is_pat (checkPat $pattern)
        (if $is_pat
            ; If it's a pattern, do the normal check
            (let $exp (if (== (size-atom $pattern) 1) (car-atom $pattern) $pattern)
                (let $vars (cdr-atom $exp)
                    (let $is_connected (has-common-element $var $vars)
                        (if $is_connected
                            $pattern
                            ()
                        )
                    )
                )
            )
            ; Not a pattern, check recursively through the structure
            (let $result (check-pattern-recursive $pattern $var)
                (if $result
                    $pattern
                    ()
                )
            )
        )
    )
)

; Check if two lists have any common element
(=(has-common-element $list1 $list2)
    (if (== $list1 ())
        False
        (if (== (get-metatype $list1) Expression)
            (let $head (car-atom $list1)
                (let $tail (cdr-atom $list1)
                    (if (element-in-list $head $list2)
                        True
                        (has-common-element $tail $list2)
                    )
                )
            )
            (element-in-list $list1 $list2)
        )
    )
)

; Check if an element exists in a list
(=(element-in-list $elem $list)
    (if (== $list ())
        False
        (if (== (get-metatype $list) Expression)
            (let $head (car-atom $list)
                (let $tail (cdr-atom $list)
                    (if (== $elem $head)
                        True
                        (element-in-list $elem $tail)
                    )
                )
            )
            (== $elem $list)
        )
    )
)

; Recursively check if any element in the pattern connects with var
(=(check-pattern-recursive $pattern $var)
    (if (== $pattern ())
        False
        (if (== (get-metatype $pattern) Expression)
            (let $head (car-atom $pattern)
                (let $tail (cdr-atom $pattern)
                    (let $head_check (process-pattern $head $var)
                        (if (not (== $head_check ()))
                            True
                            (check-pattern-recursive $tail $var)
                        )
                    )
                )
            )
            False
        )
    )
)



(=(rmvPar $x) 
    (if (== $x ()) 
        (empty) 
        (let $fuc (checkPat $x) 
            (if $fuc 
                $x  
                (if (== (size-atom $x) 1) 
                    $x 
                    $x
                )
            )
        )
    )
) 



;=================================

(= (extract $exp $var)  (let $che (var-exist-exp $exp $var)  (
    if $che 
    $exp
    (empty)
    
)))












;; =============================================================================
;; Function: sort-by-abstraction
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Sorts a list of patterns based on abstraction level using is-blk-more-abstract
;;   More abstract patterns come first in the sorted result
;;
;; Type Signature:
;;   (-> Expression Expression Expression)
;;
;; Parameters:
;;   $patterns - List of patterns to sort
;;   $var - Variable to use for abstraction comparison
;;
;; Returns:
;;   Sorted list where more abstract patterns appear first
;;
;; Example:
;;   (sort-by-abstraction '(pattern1 pattern2 pattern3) $x)
;; =============================================================================
; (: sort-by-abstraction (-> Expression Expression Expression))
(= (sort-by-abstraction $patterns $var)
    (if (== $patterns ())
        ()
        (if (== (cdr-atom $patterns) ())
            $patterns  ; Single element list is already sorted
            (let* (
                ($pivot (car-atom $patterns))
                ($rest (cdr-atom $patterns))

                ($more-abstract (filter-more-abstract $rest $pivot $var))
                ($less-abstract (filter-less-abstract $rest $pivot $var))
        

                ($sorted-less (sort-by-abstraction $less-abstract $var))
                ($sorted-more (sort-by-abstraction $more-abstract $var))
            )
            (concat-atom $sorted-more (cons-atom $pivot $sorted-less))))))

;; =============================================================================
;; Function: filter-more-abstract
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Filters patterns that are more abstract than the pivot
;;
;; Parameters:
;;   $patterns - List of patterns to filter
;;   $pivot - Pivot pattern for comparison
;;   $var - Variable for abstraction comparison
;;
;; Returns:
;;   List of patterns more abstract than pivot
;; =============================================================================
; (: filter-more-abstract (-> Expression Expression Expression Expression))
(= (filter-more-abstract $patterns $pivot $var)
    (if (== $patterns ())
        ()
        (let* (
            ($head (car-atom $patterns))
            ($is-head-abstract (is-blk-more-abstract $head $pivot $var))
            ($copyHead (car-atom $patterns))
            ($copyHead (car-atom $patterns))
            ($tail (cdr-atom $patterns))
            ($rest-filtered (filter-more-abstract $tail $pivot $var))
        )
        (if (is-blk-more-abstract $head $pivot $var)
            (cons-atom $copyHead $rest-filtered)
            $rest-filtered))))

;; =============================================================================
;; Function: filter-less-abstract
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Filters patterns that are less abstract than the pivot
;;
;; Parameters:
;;   $patterns - List of patterns to filter
;;   $pivot - Pivot pattern for comparison
;;   $var - Variable for abstraction comparison
;;
;; Returns:
;;   List of patterns less abstract than pivot
;; =============================================================================
; (: filter-less-abstract (-> Expression Expression Expression Expression))
(= (filter-less-abstract $patterns $pivot $var)
    (if (== $patterns ())
        ()
        (let* (

            ($head (car-atom $patterns))
            ($copyHead (car-atom $patterns))
            ($tail (cdr-atom $patterns))
            ($rest-filtered (filter-less-abstract $tail $pivot $var))
        )
        (if (is-blk-more-abstract $head $pivot $var)
            $rest-filtered
            (cons-atom $copyHead $rest-filtered)))))




;  !(sort-by-abstraction (((Human $x $y) (Human $x $z)) ((Human $x Chala)) ) $x)


; (((Human $x $y) (Human Abebe $y))  ((Human $x Abeb)))

; (filter-less-abstract $rest $pivot $var)

; !(filter-more-abstract (((Human $x $y) (Human $x $z))) ((Human $x Chala)) $x)

; !(is-blk-more-abstract ((Human $y $x)) ((Human Abebe Chala))  $x)


















;; =============================================================================
;; Function: eq-prob
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Calculates the probability of a variable taking the same value across
;;   all blocks/subpatterns where that variable appears in a partition
;;
;; Type Signature:
;;   (-> Expression Expression Expression Number)
;;
;; Parameters:
;;   $partition - List of blocks/subpatterns 
;;   $pattern - The main pattern containing variables
;;   $db - Database/corpus to search in
;;
;; Returns:
;;   Probability value as a number
;;
;; Algorithm:
;;   1. For each joint variable in the pattern and partition
;;   2. Get connected subpatterns containing that variable
;;   3. Sort by abstraction level (most abstract first)
;;   4. For each block after the first, find most specialized abstract block
;;   5. Calculate probability based on value counts
;; =============================================================================
; (: eq-prob (-> Expression Expression Expression Number))
(= (eq-prob $partition $pattern $db)
    (let* (($joint-vars (joint-variables $pattern $partition))
     
    
     )
        (calculate-prob-for-vars $joint-vars $partition $db 1.0)))

;; =============================================================================
;; Function: calculate-prob-for-vars
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Iterates through variables and calculates cumulative probability
;;
;; Parameters:
;;   $vars - List of joint variables
;;   $partition - Partition to analyze
;;   $db - Database
;;   $p - Current probability accumulator
;;
;; Returns:
;;   Final probability after processing all variables
;; =============================================================================
; (: calculate-prob-for-vars (-> Expression Expression Expression Number Number))
(= (calculate-prob-for-vars $vars $partition $db $p)
    (if (== $vars ())
        $p
        (let* (
            ($top (car-atom $vars) )
            ($var-partition (connected-subpatterns-with-var $partition $top))
            ($sorted-partition (sort-by-abstraction $var-partition $top))
            ($new-p (process-blocks $sorted-partition $top $db $p 1))
            
        )
        (calculate-prob-for-vars (cdr-atom $vars) $partition $db $new-p))))


;; =============================================================================
;; Function: process-blocks
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Processes blocks in sorted partition starting from index j=1
;;   (skipping the first block as per the C++ algorithm)
;;
;; Parameters:
;;   $sorted-partition - Partition sorted by abstraction
;;   $var - Current variable being processed
;;   $db - Database
;;   $p - Current probability
;;   $j - Current block index (starts at 1)
;;
;; Returns:
;;   Updated probability after processing all blocks
;; =============================================================================
; (: process-blocks (-> Expression Expression Expression Number Number Number))
(= (process-blocks $sorted-partition $var $db $p $j)
    (let $partition-size (size-atom $sorted-partition)
        (if (>= $j $partition-size)
            $p
            (let* (
                ($j-blk (index-atom $sorted-partition $j))
                ($i (find-most-specialized-abstract $sorted-partition $j-blk $var (- $j 1)))
                
                ($c (if (>= $i 0)
                        (let $i-blk (index-atom $sorted-partition $i)
                            (value-count $i-blk $var $db))
                        (let $U (collapse (get-atoms $db)) (size-atom $U))))  ; Use |U| = db.size() as fallback

                ($j-blk-count (value-count $j-blk $var $db))
                
                ($new-p (/ $p $c))
            )
            (process-blocks $sorted-partition $var $db $new-p (+ $j 1))))))






(= (value-count $blk $var $db) 
    (let $conj-blk (union-atom (,) $blk) (let*
     (
        
        ($match-values (collapse (match $db $conj-blk $var)) )
        
        ($ground-value (unique-atom $match-values))
     
     ) (size-atom $ground-value))))
;; =============================================================================
;; Function: find-most-specialized-abstract
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Finds the most specialized block that is more abstract than j_blk
;;   Goes backward from j_blk to find first i_blk that is more abstract
;;
;; Parameters:
;;   $partition - Sorted partition
;;   $j-blk - Current block to compare against
;;   $var - Variable for abstraction comparison
;;   $i - Current index to check (starts at j-1)
;;
;; Returns:
;;   Index of most specialized abstract block, or -1 if none found
;; =============================================================================
; (: find-most-specialized-abstract (-> Expression Expression Expression Number Number))
(= (find-most-specialized-abstract $partition $j-blk $var $i)
    (if (< $i 0)
        -1  ; No abstract block found
        (let $i-blk (index-atom $partition $i)
            (if (is-blk-more-abstract $i-blk $j-blk $var)
                $i  ; Found the most specialized abstract block
                (find-most-specialized-abstract $partition $j-blk $var (- $i 1))))))

;; =============================================================================
;; Helper Functions
;; =============================================================================



;; =============================================================================
;; Function: get-var
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Extracts all variables from a flattened pattern expression
;;   A flattened pattern is a list of patterns like ((Pattern $x $y) (Pattern $z Jon))
;;
;; Type Signature:
;;   (-> Expression Expression)
;;
;; Parameters:
;;   $pattern - Flattened pattern (list of individual patterns)
;;
;; Returns:
;;   List of unique variables found in the pattern
;;
;; Example:
;;   (get-var '((Pattern $x $y) (Pattern $z Jon))) â†’ ($x $y $z)


; (=(get-var $conjunct) 
;     (let $lst (collapse 
;         (let $a (car-atom $conjunct) 
;             (if (not (== $a ,)) 
;                 (let $firtype (get-metatype $a) 
;                     (if (== $firtype Expression) 
;                         (get-variables-helper (superpose $conjunct) ) 
;                         (get-variables-helper $conjunct )
;                     )
;                 ) 
;                 (let $b (cdr-atom $conjunct) 
;                     (get-variables-helper (superpose $b))
;                 )
;             )
;         )) 
;         (get-variables-step $lst ())
;     ) 
; )

(=(get-var $conjunct) 
    (let $lst
        (let $a (car-atom $conjunct) 
            (if (not (== $a ,))  
                (get-variables-from-list $conjunct)    
                (get-variables-from-list (cdr-atom $conjunct) )
            )
        )
        (get-variables-step $lst)
    ) 
)

; Helper function to recursively process list elements
(=(get-variables-from-list $lst)
    (if (== $lst ())
        ()
        (let $head (car-atom $lst)
            (let $tail-result (get-variables-from-list (cdr-atom $lst))
                (let $result (get-variables-helper $head)
                    (if (== $result ())
                        (get-variables-from-list $tail)
                        (cons-atom $result $tail-result)
                    )
                )
            )
        )
          
    )
)

(=(ret-vars $x) 
    (let $invar (checkPat $x ) 
        (if $invar (get-variables-helper $x ) 
            (if (== ( get-metatype $x ) Variable) 
                $x 
                ()
            )
        )
    )
)



(=(get-variables-helper $pattern)
    (if (== $pattern ()) 
        ()
        (let $var1 (ret-vars (car-atom $pattern)) 
            (let $tail (get-variables-helper (cdr-atom $pattern)) 
                (if (== $var1 ()) 
                    $tail 
                    (cons-atom $var1 $tail))
            )     
    )
)
)




(=(get-variables-step $lst)
    (if (== $lst ())
        ()
        (let $flatten (flatten-and-union $lst) (unique-atom $flatten))
    )
)

(=(flatten-and-union $lst)
    (if (== $lst ())
        ()
        (let $head (car-atom $lst)
            (let $tail (cdr-atom $lst)
                (let $union-tail (flatten-and-union $tail) (union-atom $head $union-tail))
            )
        )
    )
)







;; =============================================================================
;; Function: joint-variables
;; -----------------------------------------------------------------------------
;; Purpose:
;;   Finds variables that appear in multiple blocks of a partition
;;   A joint variable must exist in at least 2 different blocks
;;
;; Type Signature:
;;   (-> Expression Expression Expression)
;;
;; Parameters:
;;   $pattern - Flattened pattern to get variables from
;;   $partition - List of blocks (each block is a list of patterns)
;;
;; Returns:
;;   List of variables that appear in multiple blocks
;;
;; Example:
;;   Pattern: (, (Pattern $x $y) (Pattern $x Jon))  
;;   Partition: ( ((Pattern $x Jon))  ((Pattern $x $y)) )  
;;   Result: ($x) - because it appear in both blocks
;; =============================================================================
; (: joint-variables (-> Expression Expression Expression))
(= (joint-vars-helper $partition $uniqueVars)
   (if (== $uniqueVars ())
       ()
       (let* ( 
          ($joint-var-head (retJointvar $partition (car-atom $uniqueVars)))
          ($joint-vars-tail (joint-vars-helper $partition (cdr-atom $uniqueVars)))
        )
        (cons-atom 
           $joint-var-head 
           $joint-vars-tail)
       )
   )
)

(= (retJointvar-helper $partition $var)
   (if (== $partition ())
       ()
       (let* (
              ($jointvar-head (retJointPat (car-atom $partition) $var))
              ($jointvar-tail (retJointvar-helper (cdr-atom $partition) $var))
            )
         (cons-atom
             $jointvar-head
             $jointvar-tail)
       )
   )
)


(= (retJointvar $partition $var) 
   (let $retPats (retJointvar-helper $partition $var)
       (if (> (size-atom $retPats) 1)  
           $var 
           ()
       )
   )
)



(= (retJointPat-helper $block $var)
   (if (== $block ())
       ()
       (let* (
              ($jointpat-head (retjointSubPat (car-atom $block) $var))
              ($jointpat-tail (retJointPat-helper (cdr-atom $block) $var))
            )
         (cons-atom
             $jointpat-head
             $jointpat-tail)
       )
   )
)


(= (retJointPat $block $var)  
   (let $blo (retJointPat-helper $block $var)
       (if (> (size-atom $blo) 0) 
           $block 
           ()
       )
   )
)


(= (retjointSubPat-helper $tail $var)
   (if (== $tail ())
       ()
       (let* (
              ($subpat-head (checkSubInter (car-atom $tail) $var))
              ($subpat-tail (retjointSubPat-helper (cdr-atom $tail) $var))
            )
         (cons-atom
             $subpat-head
             $subpat-tail)
       )
   )
)


(= (retjointSubPat $subpat $var) 
   (let* (
           ($tail (cdr-atom $subpat)) 
           ($JoinedVars (retjointSubPat-helper $tail $var))
         ) 
       (if (== (size-atom $JoinedVars) 0) 
           () 
           $subpat
       )
   )
)


(=(checkSubInter $part $var) 
    (let $invar (checkPat $part) 
        (if $invar (retjointSubPat $part $var) 
            (if (and (== (get-metatype $part) Variable) (== $var $part)) 
                $part 
                ()
            ) 
        )
    )
)

;we could pass the origninal conjunct pattern and the partiton if we want,then get-variables retrunds a list of unique variables in the list
(=(joint-variables  $pattern $partition) 
    (let $invar (get-var $pattern) 
        (joint-vars-helper $partition $invar)
    )
)



;; Get all variables from entire partition (updated implementation)
; (: get-all-partition-variables (-> Expression Expression))
(= (get-all-partition-variables $partition)
    (if (== $partition ())
        ()
        (let* (
            ($block (car-atom $partition))
            ($remaining (cdr-atom $partition))
            ($block-vars (get-var $block))
            ($remaining-vars (get-all-partition-variables $remaining))
        )
        (merge-list $block-vars $remaining-vars))))

;; Find intersection of two variable lists
(: intersection-vars (-> Expression Expression Expression))
(= (intersection-vars $vars1 $vars2)
    (if (== $vars1 ())
        ()
        (let* (
            ($var (car-atom $vars1))
            (($remaining) (cdr-atom $vars1))
            ($rest-intersection (intersection-vars $remaining $vars2))
        )
        (if (is-membership $var $vars2)
            (cons-atom $var $rest-intersection)
            $rest-intersection))))



